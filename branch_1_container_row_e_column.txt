BRANCH 1 CONTAINER ROW E COLUMN


Widgets podem ser STATEFUL (alternam de estado) ou STATELESS (não alternam o estado).
Widgets Stateful alteram seus status na tela usando métodos setState.
Quando instanciamos um objeto que recebe uma função como parâmetro, esta função é declarada com seu parâmetro
desta forma:

	MyFabButton(onPressed: () => _incrementCounter(PARAMETRO_AQUI)),

Sobre importar arquivos de outras pastas dentro do projeto do app: podemos usar a referência de importação assim:

	import '../widgets/my_fab_button.dart';

onde o "../" significa "volte uma pasta", ou seja, temos a pasta X, dentro da qual está a pasta Y (onde está nosso código
atual) e a pasta "widget", que é onde está a classe que queremos importar. O comando "../" significa "volte da pasta
atual (pasta Y) para a pasta anterior (pasta X) e nela acesse a pasta "widgets".

Widgets desta aula:

Container: cria uma forma (por default, um quadrilátero) na tela.
		Possui os atributos:
			
			height
			width
			color: define a cor, pode receber "Colors.grey.shade300", por exemplo, para mudar o tom da cor
				 (veja abaixo sobre o uso de cores).
			decoration: define a forma, recebe um objeto "BoxDecoration" que possui o atributo:

						shape: recebe um objeto "BoxShape", como "BoxShape.circle".

					 **ATENÇÃO**: se estivermos usando um objeto "BoxDecoration", o atributo "color"
							   deve ser fornecido dentro do "BoxDecoration", e não fora dele, dentro apenas
							   do Container.

			borderRadius: arredondamento da borda, recebe um objeto "BorderRadius" que recebe como parâmetro 
					   um valor numérico, assim:

							borderRadius: BorderRadius.circular(12.0),

					   Podemos também arredondar apenas uma das bordas da figura, assim:

							borderRadius: BorderRadius.only(
										topLeft: Radius.circular(12.0)),

			child: pode receber outro objeto Container, que aparece dentro do objeto pai.


Row: organiza os filhos horizontalmente.
	Pode receber como filhos uma lista de widgets que recebe um objeto "Expanded" que recebe um filho, fazendo com que
	ocupem todo o espaço disponível, assim:

		Row(
			children: const <Widget> [
				Expanded(
					child: FILHO1,
				),
				Expanded(
					child: FILHO2,
				),
			],
		)


Column: mesma coisa, porém organiza os filhos verticalmente.
	   Dentre os atributos, "mainAxisAlignment" define o alinhamento dos objetos. Se for ".start" ele começa na parte de 
	   cima da tela.


Padding: adiciona espaço entre o widget e as bordas da tela ou outros widgets. A sintaxe é a seguinte:

		Padding(
			padding: const EdgeInsets.all(8.0),
			child: Container (
				color: Colors.white,
				heigth: 40.0
				width: double.infinity // aqui creio que ele tenha definido o comprimento como máximo na tela
			),
		)

	   O padding pode ser também em apenas um lado, como no comando:

		padding: const EdgeInsets.only(left: 8.0),	


	**TIP** apertando ctrl+shift+p e digitando ">Flutter: Toggle Debug Painting" é exibido na tela as "linhas de grade"
			dos objetos exibidos.


CircleAvatar: já cria um "container" visual redondo para ser uma imagem de perfil.

SingleChildScrollView: é recebido diretamente pelo "body" do Scaffold e dentro dele estão todos os demais widgets. Permite
					que a tela seja scrollada.


--------------------

Podemos simplificar as coisas separando "contatos" de "contactListTile" (a barrinha que exibe o contato).

Primeiro criamos a classe "Contact" com as informações como nome, telefone, cargo, etc.
Depois, criamos a classe "ContactListTile" que é o widget visual que vai exibir essas informações na tela.
Por fim, criamos uma classe "HomeController" que recebe uma lista com os Contacts, assim:

	class HomeController {
		List<Contact> contacts = [
		
			LISTA DE CONTACTS
			
		];
	}

Depois, criamos um atributo "controlle" na classe HomePageContacts que recebe a classe "Controller" já com os Contacts,
assim:

	final controller = HomeController();

Depois, exibimos as informações do Contact no ContactListTile no Scaffold da homepage assim:

	body: Column(
		mainAxisAlignment: MainAxisAlignment.start,
		children: contacts.map(
			(e) => ContactListTile(
				url: e.url,
				name: e.name,
				jobTitle: e.jobTitle,
			),
		),
	).toList(),

Onde "e" significa "Contact da vez" (semelhante ao índice "i" de um loop for) dentro de um map de Contacts.
Repare que usamos "contacts.map" para transformar a lista "contacts" em um map e depois ao final precisamos usar o comando
".toList()" para transformá-lo novamente em uma lista.











