BRANCH 9 - API's

API é uma interface que permite que um sistema se comunique com o outro.

Rest API é um conjunto de boas práticas usadas nas requisições HTTP
Rest APIs geralmente são desenvolvidas pelo back-end, geralmente entregam dados na forma de map, JSON ou XML.
99% usam JSON ou map.

Possuem os seguintes métodos:

	- Post: criar novos dados no servidor
	- Get: leitura de dados
	- Put: atualizar dados
	- Delete: excluir informações do servidor
	- Fetch

JWT: token recebido ao logar em uma API que nos identifica dentro da aplicação e nos permite acessar apenas os dados
	permitidos. Assim, os dados são transferidos pela rede de maneira segura.

	Após enviarmos os dados para o servidor da API, ela retorna um token de autenticação. O token é uma série de 
	caracteres que formam uma sentença criptografado.

	Por questões de segurança um token não costuma durar muito tempo (no máximo 30 dias). Podemos usar refresh token
	para fazer o tempo de validação durar mais.

Passos para consumir API no Flutter:

1 - Adicionar o package de API "Dio", que nos permite usar protocolos de requisição de API (de forma semelhante ao
	protocolo HTTP).
	Acessar "pub.dev/packages/dio", copiar o trechinho para colar no pubspec.yaml.
	Digitar no terminal do VS Code "flutter pub add dio".

2 - Na pasta "lib" criar a subpasta "src" ("sources") e nela a subpasta "get_sentences" e nela criar os arquivos:

		sentence_page.dart
		sentence_controller.dart
		sentence_repository.dart

3 - No "sentence_repository.dart" nós iremos pegar os dados e transferí-los para uma estrutura que conhecemos.
	Para isso, criamos a classe "SentenceRepository" que possui a função assíncrona "getSentence" para pegar dados
	da API. Essa função é do tipo "Future<T>", ou seja, um Future cujo tipo ("T") precisa ser especificado, assim:

		class SentenceRepository {

			Future<List> async {}

		}
		
	No caso, a nossa API nos retorna listas de maps de frases, assim:

		[
			{
				"quote": "Because I say so.",
				"author":	"Walter White",
			}
		]

	Lidando com maps é mais fácil ter uma classe que traduz esse map pra um objeto lidável dentro do código, então
	criamos na pasta "src" a subpasta "models" e nela o arquivo "quote_model.dart" com a classe "Quote":

		class Quote {

			final String quote;
			final String author;
		
			Quote ({
				required this.quote,
				required this.author,
			});

		}

	Essa função pode ter um método para automaticamente converter um map da API em um objeto "Quote":

		factory Quote.fromMap(Map<String,dynamic>?map){
			
			return Quote(
				quote: map['quote'],
				author: map['author'],
			)

		}

	Ou podemos também usar um modo mais fácil de construir isso que é apenas criar a classe assim:

		class Quote {

			final String quote;
			final String author;

		}

	e clicar na palavra "Quote", pressionar Ctrl+D e selecionar "generate data class" que vai criar métodos:

		copyWith
		toMap
		fromMap (que é basicamente o mesmo método que criamos manualmente anteriormente, porém retornando
				um valor vazio ('') caso o dado buscado não exista.

	outra opção ainda é pesquisar "JSON to Dart" no google, acessar o primeiro link ("javiercbk etc etc"), colar
	ali o map do quote (mostrado acima), escrever o nome da nossa classe (Quote) e clicar em "Generate Dart".


4 - Agora já tendo um método que transforma os dados da forma de map para uma classe (uma forma mais fácil de trabalhar),
	podemos criar na classe SentenceRepository um método que retorna dados na forma da nossa classe Quote.
	Primeiro, criamos o atributo "dio" na classe "SentenceRepository":

		class SenteceRepository {

			final Dio dio = Dio(
				BaseOptions(
					baseUrl: 'https://api.breakingbadquotes.xyz/v1',
					headers: {
							'Authentication' : 'Bearer $token',
						}
				)

			);

		}

	Neste método instanciamos um objeto da classe "Dio", que recebe como "baseUrl" a URL base da API (a parte do
	endereço de URL que é igual para todas as subpáginas da página da URl) e também, por exemplo, o "headers", que
	é o cabeçalho da requisição, que neste caso recebe um map com o token de autenticação.

	Trabalhar com uma classe é melhor do que com maps porque evita que digitações errôneas de chaves causem problemas
	no código. Criando um método que transforma os dados da forma de map para uma classe nós chamamos a chave apenas
	no método, de forma padronizada, sem precisar digitar novamente a cada ação de chamar um map.

	Depois, criamos o método que retorna dados na forma da nossa classe Quote:

		Future<List<Quote>> getSentence() async {
			
			final response = await dio.get('/quotes');

			final data = List.from(response.data);

			final mapList = data.map((e) => Map<String, dynamic>.from(e)).toList();

			return mapList.map((e) => Quote.fromMap(e)).toList();

		}

	Repare que '/quotes' é o "endpoint", ou seja, o trecho final da URL que vem após a baseURl, já informada na classe.

	Em "final data = List.from(response.data);" fazemos uma lista a partir dos dados do objeto "response" (response.data),
	sendo que transforma dados do tipo dynamic do "reponse" em dados do tipo List<dynamic> do "data".

	Em "final mapList = data.map((e) => Map<String, dynamic>.from(e)).toList();" transformamos cada item ("e", que
	equivale ao índice "i" de um loop for) do objeto "data" do tipo List<dynamic> para o tipo Map e depois para uma
	lista de objetos do tipo Map<String, dynamic>.

	Por fim, em "mapList.map((e) => Quote.fromMap(e)).toList();" fazemos o parse (conversão) do tipo Map<String, dynamic>
	para objetos da classe Quote, retornado uma lista de objetos do tipo Quote.

	Usamos também uma classe "SentenceController":

		class SentenceController {

			final SentenceRepository repository;

			const SentenceController({required this.repository});

			Future<List<Quote>> getSentence() async {
			
				return await repository.getSentence();

			}

		}	
	
	Aqui sequer trabalhamos com maps, simplesmente usamos o método da classe "SentenceRepository".

Pronto, agora podemos programar a tela para lidar com dados de API.
Agora na classe "_MyHomePageState" temos um novo atributo controller e no seu Scaffold vamos usar no atributo body
o widget "FutureBuilder":

	class _MyHomePageState extends State<MyHomePage> {

		final controller = SentenceController(repository: SenteceRepository);

		...SCAFFOLD CONSTRUÍDO AQUI ETC ETC

		body: FutureBuilder(
				future: controller.getSentence(),
				builder: (context, snapshot) {
					if (!snapshot.hasData && !snapshot.hasError) {
						return Center(
							child: PaginaAguardando(),
						);
					} else if (snapshot.hasError) {
						return Center(
							child: PaginaDeErro(),
						);
					} else if (snapshot.hasData && snapshot.hasError) {
						return const Center(
							child: Text('Não há dados para mostrar.'),
						);
					}
					return ListView.builder(
						itemCount: snapshot.data.length,
						itemBuilder: (context, index) {
							return Card(
								child: Column(
									children: <Widget> [
										Text(snapshot.data![index].quote),
										Text(snapshot.data![index].author),
									],
								),
							),
						},
					);
				
				}
			),

	}
		

	Onde "snapshot" é a "imagem" (os dados) que virão da API.
	O widget FutureBuilder sempre chama a API novamente a cada setState.





EXTRA:

	Ctrl+D (ou, talvez, Ctrl+Shift+D) seleciona todas as versões de algo
	Ctr+Shift+seta (ou, talvez, Ctr+Shift+End) para selecionar todo o resto da linha (para o lado da seta utilizada)
	












































