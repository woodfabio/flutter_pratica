BRANCH 5 - TextEditingController, botões, GestureDetector, InkWell

Podemos criar atributos na classe _CreateAccountState com controllers para todos as variáveis de texto:

	final _nameController = TextEditingController();
	final _phoneController = TextEditingController();

Então cada CustomTextField pode receber seu prórpio controller, assim:

	controller: _nameController;

Assim, os dados entrados no campo de preenchimento serão armazenados em um controller e poderão ser mais facilmente
manipuláveis, pois permitem operações como;

	_nameController.clear
	_nameController.value.text

Pois os TextFormFields possuem uma gerência própria independente da página, não necessitando de um setState.

Há uma função em específico:

	_nameController.addListener(() {});

Que recebe uma função como parâmetro e executa-a sempre que houver uma alteração de valor.
Exemplo:

	_nameController.addListener(() {
		Validator.validateCpf(_cpfController.text);
	});

Assim, o CPF inserido será validado cada vez que for alterado.

Sempre devemos ter um método dispose, assim:

	@override
	void dispose() {
		_nameController.removeListener(() {});
		super.dispose();
	}

Para que os controller parem de ser monitorados ao fim do uso.

**TIP** para evitar que os campos de preenchimento sumam quando o teclado sobe para preenchimento, sempre encapsular
o Form (e demais wraps que o envolvam) em um SingelChildScrollView (que ficará encapsulado em um SafeArea).


-----------------

BOTÕES

Temos os padrões:

	- FloatingActionButton
	- IconButton
	- ElevatedButton

E ainda podemos personalizar botões usando:

	- GestureDetector
	- InkWell

InkWell já vem com uma animação de resposta ao toque, GestureDetector não (embora possa receber uma animação programada
pelo desenvolvedor).

Esses botões personalizados recebem qualquer coisa. Podem p. ex. envolver o Scaffold em um desses botões, assim qualquer
área que não for um filho clicável (como outro botão) será clicável. É útil, por exemplo, para poder sair do teclado
apenas tocando em qualquer local da tela (unfocus). 

Um botão pode ser um widget Stateless e mesmo assim ter mudanças de estado em uma propriedade sua.
Exemplo em um ElevatedButton:

	backgroundColor: MaterialStateProperty.resolveWith<Color?> {
		(set<MaterialState> states) {
			if (states.contains(MaterialState.hovered))
				return Colors.redAccent;
			if (states.contains(MaterialState.disabled)) 
				return Colors.grey;
			if (states.contains(MaterialState.pressed))
				return null;			
		}
	}
































