	BRANCH 6 - Dialogs, BottomSheet, separação apresentação/lógica

Dialogs:

Abre uma segunda tela ("pop-up") no meio da tela, bloqueando o resto dela. Possui 3 tipos:
		
		- showDialog
		- AlertDialog
		- SimpleDialog

Podemos criar um SimpleDialog, por exemplo, para confirmar o cadastro no ContactApp. Após pressionar o botão "cadastrar",
é mostrado um SimpleDialog com os parâmetros:

	title: const Text('Confirme seus dados'),
	insetPadding: EdgeInsets.all(16.0),
	shape: RoundedRectangleBorder(
			borderRadius: BorderRadius.circular(16.0),
		),
	contentPadding: const EdgeInsets.all(16.0),
	
e também como parâmetro "children" uma lista de widgets "RichText" (que é um widget de texto que aceita mútliplos estilos
de texto em uma mesma linha), assim:

	children: [
		RichText(
			text: TextSpan(
				text: 'Nome: ',
				style: texTheme.titleSmall, // tema criado como atributo do metodo builder do Dialog 
				children: [
					TextSpan(
						text; name, // variavel já existente
						style: textTheme.bodyMedium,
					),
				],
			),
		),
	],

Qualquer TextSpan que não tenha um textTheme definido irá usar o tema padrão, que geralmente é o tema do TextSpan pai.
No caso, se o TextSpan que exibe o conteúdo da variável "name" não tivesse o Text.bodyMedium definido, o seu tema seria
TextTheme.titleSmall, que é o tema do TextSpan pai.

No cadastro do ContactApp, o botão de cadastro recebe no atributo onPressed a função "showDialog", que exibe um widget
"ConfirmCreateAccountDialog", assim:

	CustomElevatedButton(
		onPressed: () {
			if (_formKey.currentState != null &&
			    _formKey.currentState!.validate()) {
				showDialog(
					context: context,
					useSafeArea: true,
					barrierDismissible: false,
					builder: (_) => ConfirmCreateAccountDialog(
									name: _nameController.text,
									phone: _phoneController.text,
								),
				);
			}
		},
	),

Repare que o underscore usado entre os parênteses da função que alimenta "builder" simplesmente indica que estamos
desconsiderando este parâmetro (normalmente ele receberia "context").

"barrierDismissible" quando falso impede o clique/toque válido fora da área do Dialog.
Repare que ConfirmCreateAccountDialog armazena os dados que serão exibidos (nome, fone, etc.).

ConfirmCreateAccountDialog também tem um CustomElevatedButton que tem como função do onPressed "Navigator.pop(context)",
que navega para a página anterior. Esse CustomElevatedButton também pode, além de executar a navegação, chamar outro
showDialog que exibe o widget "CircularProgressIndicator()", que exibe a animação de loading, assim:

				CustomElevatedButton(
					onPressed: () {
						Navigator.pop(context);
						showDialog(
							context: context,
							builder: (_) => const Center(
										child: CircularProgressIndicator(),
									),
						);
					},


	**TIP** é comum que os Dialog não se atualizem com o hot reload.


Existe ainda o "AboutDialog", que é um Dialog já configurado para exibir informações sobre o aplicativo.

-------
	
BottomSheet:

	Abre uma segunda tela ("pop-up") a partir da parte de baixo tela, bloqueando o resto dela. Possui 2 tipos:
		
		- showModalBottomSheet
		- showBottomSheet

Assim como o Dialog, recebe um context e um builder:

				showBottomSheet(
					context: context,
					useSafeArea: true,
					barrierDismissible: false,
					builder: (_) => ConfirmCreateAccountBottomSheet(
									name: _nameController.text,
									phone: _phoneController.text,
								),
				);


A diferença do showModalBottomSheet é que ele independe do Scaffold e bloqueia o toque no resto da tela.

Repare que mesmo que a tela de fundo esteja com o toque bloqueado o botão de voltar do aparelho celular ainda funciona. Para
evitar isso, fazemos:

				showBottomSheet(
					context: context,
					useSafeArea: true,
					barrierDismissible: false,
					builder: (context) => WillPopScope(
								onWillPop: () => Future.value(false),
								child: ETCETCETC
					),
				);


É importante que o widget SafeArea que envolve o BottomSheet receba o seguinte atributo:

	bottom: true,

para colocar um espaçamento entre a parte de baixo do "pop-up" e o final da tela.

--------

NAVEGAÇÃO

Para organizar a navegação entre os TextForm do cadastro, podemos criar vários "focus node", que são pontos de foco da
navegação.
Vejamos como passar do TextField do campo "name" direto para o TextField do campo "phone".
Primeiro, nosso CustomTextField recebe os atributos:

	final FocusNode? focusNode;
	final Function(String)? onFieldSubmitted;

E depois na classe _CreateAccountState criamos os atributos:

	final _nameFocusNode = FocusNode();
	final _phoneFocusNode = FocusNode();

Agora na hora de usar os TextField, na hora de criar o TextField do campo "name", alimentamos estes atributos:

	onFieldSubmitted: (_){
		_nameFocusNode.unfocus();
		FocusScope.of(context).requestFocus(_phoneFocusNode);
	}



Vamos criar uma classe "CreateAccountController" para armazenar a lógica da criação do usuário cadastrado:

	class CreateAccountController {
		const CreateAccountController();

		Future<bool> crateAccount({
			required String name,
			required String phone,
		}) async {
			try {
				await Future.delayed(const Duration(seconds: 3));
				return true;
			} catch (e) {
				return false;
			}
		}
	}

A expressão "await Future.delayed(const Duration(seconds: 3))" simula uma demora de 3 segundos de chamada de API que cria
a conta de usuário.
O "try" tenta fazer a chamada:
	caso funcione, retorna true;
	caso não funcione, "cai" no "catch (e)" e retorna falso.

Depois, vamos na classe _CreateAccountState e criamos o atributo:

	final controller = const CreateAccountController();

Depois, no CustomElevatedButton do ConfirmCreateAccountBottomSheet usado nesta classe criamos o atributo:

	final VoidCallback onConfirm;

onde "VoidCallBack" é uma função que será executada ao confirmarmos o cadastro no botão.

Assim, ao usarmos o ConfirmCreateAccountBottomSheet no _CreateAccountState, o seu CustomElevatedButton receberá a função
assim:

		
	CustomElevatedButton(
		onPressed: () {
			if (_formKey.currentState != null &&
			    _formKey.currentState!.validate()) {
				FocusScope.of(context).unfocus();
				showModalBottomSheet(
					context: context,
					builder: (_) => ConfirmCreateAccountBottomSheet(
									name: _nameController.text,
									phone: _phoneController.text,
									onConfirm: () async {
										final response = await controller.createAccount(
											name: _nameController.text,
											phone: _phoneController.text 
										);
										if (response) {
											Navigator.pop(context);
											Navigator.pushReplacement(
												context,
												MaterialPageRoute(builder: (context) => HomePage(),
											);
										} else {
											Navigator.pop(context);
											showDialog(
												context: context,
												builder: (context),
												return SimpleDialog(
													title: Text('Algo deu errado!'),
													children: [
														SimpleDialogOption(
															child: Text('Voltar'),
															onPressed: () {
																Navigator.pop(context);
															},
														),
													],
												);
											);
										}
									},
								),
				);
			}
		},
	),


Repare que o atributo "onConfirm" do ConfirmCreateAccountBottomSheet recebe uma função que, por sua vez, usa a função
"createAccount" da variável "controller" (que é da classe CreateAccountController) que:

	quando recebe true, encaminha o usuário para a homepage;
	quando recebe false, exibe um Dialog com mensagem de erro.


Gerenciamento de estados:
Vamos usar a classe CreateAccountController.

No mesmo arquivo (mas fora da classe) criamos determinados estados possíveis em uma tela através de "enum", assim:

	enum CreateAccountState { empty, loading, success, error };

E criamos o atributo de função:

	final VoidCallBack onUpdate;

Sendo que o construtor será:

	const CreateAccountController({
		required this.onUpdate,
	});

Agora, ao criar o controller na classe "CreateAccountBottomSheet" fazemos assim:

	late final CreateAccountController controller = CreateAccountController(onUpdate: (p0) {
		setState(() {});		
	});



E criamos o atributo "state" que recebe o estado "empty" como default:

	CreateAccountState state = CreateAccountState.empty;

E o atributo de função:

	final VoidCallBack onUpdate;

E depois na hora de buildar a tela, fazemos uma estrutura condicional que de acordo com o atributo "state" da tela, retorna
uma construção de tela diferente.

Para isso, usamos a seguinte função criada na classe CreateAccountState:

	void updateState(CreateAccountState _state) {
		state = _state;
		onUpdate();
	}


(parei as anotações aqui porque estava ficando muito complexo e eu preciso terminar as aulas logo, depois continuo
adequadamente as anotações)













