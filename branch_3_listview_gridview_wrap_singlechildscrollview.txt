BRANCH 3 Listview, GridView, Wrap, SingleChildScrollView

ListView: exibe uma lista scrolável de widgets na tela, pode ser vertical ou horizontal.
		Nele, apenas os widgets em tela são buildados.
		É recebido pelo body do Scaffold.


		Existem 3 tipos:

			- Comum
			- ListView.builder: gera a lista inteira. Recebe como atributos a quantidade de itens (itemCount).
							Também possui o atributo "itemBuilder" que recebe os widgets que serão exibidos.
							Usa-se esta sintaxe:

								itemBuilder: (context, index) {
          								return ContactListTile(
            								contact: controller.contacts[index],
            							);
        							}

							Onde "context" é o contexto atual e "index" indica os índices dos widgets na telas.
							
			- ListView.separated: igual ao anterior, mas cria um separador entre os widgets, assim:

								separatorBuilder: (context, index) {
          								return const Divider(
            								thickness: 2.0,
            							);
        							}

							Pode-se ainda definir separadores diferentes ao mesmo tempo, assim:	

								separatorBuilder: (context, index) {
          								return const Divider(
            								thickness: 2.0,
										color: index % 2 == 0 ? Colors.blue : Colors.green,
            							);
        							}

							Aqui, o separador após os widgets pares será azul e após os ímpares será verde.

							O separador também poderá ser apenas um espaço, nesse caso ele receberá um
							widget "SizedBox".


		ATENÇÃO: ListView é mais indicado para widgets de tamanho fixo, widgets de tamanho variável (ex.: que se
		expandem) podem dar problema. Ex.: quando o widget é expandido, a tela é scrolada e ele sai da tela visível, ao
		voltar para ela ele será buildado novamente e, portanto, estará no estágio inicial (fechado).

		Podemos alterar a animação de quando não há mais nada a ser scrolado no atributo "physics".

		Podemos criar um botão que volta para o topo.
		Primeiro criamos uma variável que recebe "ScrollController()", assim:

			final scrollController = ScrollController();

		Depois, no widget ListView, criamos o atributo "controller", assim:

			controller: scrollController,

		Por fim, usamos esta sintaxe, inde criamos um TextButton que recebe como função "scrollController.animateTo" e
		um texto "Voltar ao topo":

			itemBuilder: (context, index) {
	          		if (index == controller.contacts.length - 1) {
	            		return Column(
	              			children: [
	                				ContactListTile(
	                					contact: controller.contacts[index],
	              				),
	              				TextButton(
	                					onPressed: () {
	                  					scrollController.animateTo(
	                    						0,
	                    						duration: const Duration(seconds: 1),
	                    						curve: Curves.easeIn,
	                    					);
	                					},
	                					child: const Text(
	                  					'Voltar ao topo'
	                  					),
	                					),
	              			],
	            		);
	          		}
	            	return ContactListTile(
	                		contact: controller.contacts[index],
	              	);         
	        	}

	Para fazer um botão que vai até o final o esquema é igual, com apenas esta mudança:

		scrollController.animateTo(
			scrollController.position.maxScrollExtent,
	          	duration: const Duration(seconds: 1),
	           curve: Curves.easeIn,
	      );		


	**TIP** "Set" é um tipo de lista com elementos únicos (elementos iguais não se repetem), assim:

		Set<String> = jobs;
		jobs = contacts.map((element) => element.jobTitle).toSet();

			

Wrap: exibe uma lista como se fosse uma linha de texto, é uma linha horizontal que quebra quando chega ao fim da página.

	Podemos fazer com ele uma lista de tags (widget "Chip") assim:

		Wrap(
			children: List.generate(
				jobs.length,
				(index) => Padding(
					padding: const EdgeInsets.symetric(horizontal: 0.4),
					child: Chip(
						label: Text(jobs.elementAt(index)),
					),
				),
			),
		)


	Podemos usar esses Chips para filtrar dados.
	Primeiro criamos estes atributos e função no arquivo controller:

		String currFilter = '';
		late List<Contact> showedContacts;

		void ShowFilteredList(String value) {
			if (value.isEmpty || value == currFilter) {
				currFilter = '';
				showedContacts = contacts;
			}
			else if (value.isNotEmpty && value != currFilter) {
				currFilter = value;
				showedContacts = contacts.where((element) => element.jobTitle == value).toList();
			}
		}

	Depois, no arquivo home_page, encapsulamos o Chip em um "InkWell" que recebe a função "ShowFilteredList" no
	atributo "onPressed", assim (e também precisamos mudar o tipo da classe HomePage para StatefulWidget):

		Wrap(
			children: List.generate(
				jobs.length,
				(index) => Padding(
					padding: const EdgeInsets.symetric(horizontal: 0.4),
					child: InkWell(
							onTap: () {
								controller.showFilteredList
							},
							child: Chip(
								label: Text(jobs.elementAt(index)),
								backgroundColor: jobs.elementAt(index) == currFilter ? Colors.blue : null,
							),
					),
				),
			),
		)

	Por fim, alteramos todos as vezes onde é escrito "contacts" para "showedContacts".


GridView: mostra os widgets na forma de grade. Vamos criar outro arquivo de homepage para trabalhar com esse modo.
		É recebido pelo body do Sacaffold, assim:

			body: GridView(
				gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),
				children: [],
			)

		Este objeto "GridDelegade" pode ser:

			SilverGridDelegateWithFixedCrossAxisCount: define-se o número de itens por linha
			SilverGridDelegateWithMaxCrossAxisExtent: o número de itens por linha é definido pelo tamanho da tela

		No caso do código acima, é um SliverGridDelegateWithFixedCrossAxisCount com 3 itens por linha.

		Para usar SilverGridDelegateWithMaxCrossAxisExtent, fazemos assim:

			body: GridView(
				gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent(
					maxCrossAxisExtent: MediaQuery.of(context).size.width,
				),
				children: [],
			)

		**TIP** não esquecer de mudar a classe recebida pelo atributo "home" da classe "MyApp", no arquivo main!

		Podemos fazer a mesma coisa usando método builder:

			body: GridView.builder(
				gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(crossAxisCount: 3),
				itemCount: controller.contacts.length,
				itemBuilder: (context, index) {
					return ProfileSquare(contact: controller.contacts[index]); // ProfileSquare: classe criada em aula!
				}
			)

		Usando o método builder usamos menos memória (pois contrói apenas o que está na tela) e não precisamos fazer
		conversões pra map.
		




















